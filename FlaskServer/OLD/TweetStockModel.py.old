    #--------- OLD DEPRECATED FUNCTIONS (COULD BE REUSED) -------#
    def get_tweets_table_dict_result_old(self, tweets_dict):
        # init dict
        res_dict = {
            'ticker': [],
            'tweet_id': [],
            'user_engagement': [],
            'tweet_likes': [],
            'tweet_replies': [],
            'tweet_retweets': [],
            'sentiment_pos': [],
            'sentiment_neu': [],
            'sentiment_neg': [],
            'sentiment_compound': []
        }

        # push values
        for tweet in tweets_dict:
            res_dict['ticker'].append(self.ticker)
            res_dict['tweet_id'].append(tweet['tweet_id'])
            res_dict['user_engagement'].append(tweet['u_engagement'])
            res_dict['tweet_likes'].append(tweet['n_likes'])
            res_dict['tweet_replies'].append(tweet['n_replies'])
            res_dict['tweet_retweets'].append(tweet['n_retweets'])
            if self.features_version == 1:
                res_dict['sentiment_pos'].append(tweet['s_pos'])
                res_dict['sentiment_neu'].append(tweet['s_neu'])
                res_dict['sentiment_neg'].append(tweet['s_neg'])
                res_dict['sentiment_compound'].append(None)
            elif self.features_version == 2:
                res_dict['sentiment_pos'].append(None)
                res_dict['sentiment_neu'].append(None)
                res_dict['sentiment_neg'].append(None)
                res_dict['sentiment_compound'].append(tweet['s_compound'])
        return pd.DataFrame.from_dict(res_dict)

    
    # replaced by get_scale_and_mean
    def tsm_get_df_mean_old(self, df, n_past=N_PAST):
        if n_past == 1:
            df_dict = {}
            for col in df:
                df_dict[col] = []
                df_dict[col].append(df[col].mean())
            return pd.DataFrame.from_dict(df_dict)
        else:
            return df.groupby(by='date').mean().reset_index()

    def scale_seq(self, seq):
        scaler = MinMaxScaler()
        return scaler.fit_transform(seq)




 #----------- Moved to DataHandler.py -----------#
    """
    # Step 3
    def filter_tweets(self, tweets, threshold=MIN_TWEET_STATS_SUM):
        # print(f"Filtering Tweets of {self.ticker} for {self.ip}")
        tweets_to_remove = []
        # print("len before", len(tweets))
        for tweet in tweets:
            if tweet['s_compound'] == 0.0 or tweet['s_neu'] == 1.0 or tweet['n_retweets'] + tweet['n_likes'] + tweet['n_replies'] < threshold:
                tweets_to_remove.append(tweet)

        for tweet in tweets_to_remove:
            tweets.remove(tweet)

        # print("len after", len(tweets))
        # for tweet in tweets:
        #     print(tweet['s_neu'])
        return tweets
    
    # Step 4
    def get_users_engagement(self, tweets, max_tweets_results=MAX_USER_TWEETS_RESULT, twitter_version=TWITTER_VERSION):
        # print(f"Getting user engagement of {self.ticker} for {self.ip}")
        if twitter_version == 1:
            pass
        elif twitter_version == 2:
            prms = {
                'max_results': max_tweets_results,
                'exclude': 'retweets,replies',
                'tweet.fields': 'public_metrics',
            }

            for i, tweet in enumerate(tweets):
                try:
                    u_tweets = self.twitter.request(
                        resource='users/:'+tweet['u_id']+'/tweets', params=prms)
                    u_log_n_followers = math.log(tweet['u_n_followers'], 2)
                    u_n_tweets, u_n_rts, u_n_replies, u_n_likes = 0, 0, 0, 0
                    for u_tweet in u_tweets:
                        u_n_rts += u_tweet['public_metrics']['retweet_count']
                        u_n_replies += u_tweet['public_metrics']['reply_count']
                        u_n_likes += u_tweet['public_metrics']['like_count']
                        u_n_tweets += 1
                    # print(u_n_tweets, u_n_rts, u_n_replies, u_n_likes, u_log_n_followers)
                    if math.log(u_log_n_followers, 2) > 0 and u_n_tweets > 0:
                        eng = (u_n_rts + u_n_replies + u_n_likes) / \
                            math.log(u_log_n_followers, 2)/u_n_tweets
                    else:
                        eng = 0
                    tweets[i]['u_engagement'] = eng

                except TwitterRequestError as err:
                    if "429" in str(err):
                        err_msg = "429 in err"
                        print(err_msg, err)
                        tweets[i]['u_engagement'] = 0
                        # time.sleep(15*60) # sleep 15 mins
                    else:
                        err_msg = "twitter request error"
                        print(err_msg, err)
                        tweets[i]['u_engagement'] = 0
                except Exception as err:
                    err_msg = "general exception"
                    print(err_msg, err)
                    tweets[i]['u_engagement'] = 0

        return tweets
    
    # Step 5
    def filter_users(self, tweets, threshold=MIN_USER_FOLLOWERS):
        # print(f"Filtering users of {self.ticker} for {self.ip}")
        tweets_to_remove = []
        for tweet in tweets:
            if tweet['u_n_followers'] < threshold or tweet['u_engagement'] == 0:
                tweets_to_remove.append(tweet)

        for tweet in tweets_to_remove:
            tweets.remove(tweet)

        return tweets
     
    # Step 6.0
    def prep_data(self, df):
        # print(f"Prepping model data of {self.ticker} for {self.ip}")
        # 1 Select features
        df = DataHandler.tsm_get_scale_and_mean(df)
        df = df[self.feature_set]

        # 2 Get df mean
        # print('before mean', df, len(df), df.shape)
        # df = self.get_scale_and_mean(df)
        # print('after mean', df, len(df), df.shape)

        # 3 Create sequence from df
        test_seq = DataHandler.tsm_create_sequence(df)
        # print('\n\n', test_seq, test_seq.shape)

        # 4 Scale data
        test_seq = test_seq.reshape(
            (len(test_seq), test_seq.shape[0] * test_seq.shape[1]))
        # scaled_test_seq = scale_seq(test_seq)

        # Return preped data
        return tf.convert_to_tensor(test_seq, dtype=tf.float32), df
    
    
    # Step 7.0
    def get_tweets_table_dict_result(self, tweets_df):
        features = ['tweet_id', 'u_engagement', 'n_likes', 'n_replies',
                    'n_retweets', 's_pos', 's_neu', 's_neg', 's_compound']
        renames = {
            'u_engagement': 'user_engagement',
            'n_likes': 'tweet_likes',
            'n_replies': 'tweet_replies',
            'n_retweets': 'tweet_retweets',
            's_pos': 'sentiment_pos',
            's_neu': 'sentiment_neut',
            's_neg': 'sentiment_neg',
            's_compound': 'sentiment_compound'
        }
        return tweets_df[features].rename(columns=renames).to_dict(orient='records')
    
    # Step 7.1

    def get_pred_table_dict_result(self, prepared_df, prediction):
        # init dict
        res_dict = {}
        # push values
        res_dict['ticker'] = [self.ticker for i in range(len(prepared_df))]
        res_dict['prediction'] = [prediction for i in range(len(prepared_df))]
        for col in prepared_df:
            res_dict[col] = []
            for val in prepared_df[col]:
                res_dict[col].append(val)
        return pd.DataFrame.from_dict(res_dict).to_dict(orient='records')
    """
 #----------- End Moved to DataHandler.py -----------#
